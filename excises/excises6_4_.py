#汉诺塔，大盘在下，小盘在上
#编写move(n,a,b,c)函数，它接收参数n，表示3个柱子ABC中第1个柱子A的盘子数量，然后打印出把所有盘子从A借助B移动到C的方法。
def move(n, a, b, c):
    if n == 1:
        print(a, '-->', c)
    else:
        move(n-1, a, c, b)
        print(a, '-->', c)
        move(n-1, b, a, c)
    

move(3, 'A', 'B', 'C')
# 期待输出:
# A --> C
# A --> B
# C --> B
# A --> C
# B --> A
# B --> C
# A --> C
print('-----------------')
# A --> B
# A --> C
# B --> C
move(2, 'A', 'B', 'C')
print('-----------------')
move(4,'A', 'B', 'C')
# A --> B
# A --> C
# B --> C
# A --> B
# C --> A
# C --> B
# A --> B
# A --> C
# B --> C
# B --> A
# C --> A
# B --> C
# A --> B
# A --> C
# B --> C

#我的理解:最大的盘子永远再最下面,那么对于有n个盘子的A柱,先把它上面的n-1个盘子挪到一起
#(为什么要一起呢?因为只有三根柱子,移走的目的是让A中最底下也是最大的盘子移到C柱,那么这n-1个盘子要看成整体移动到B柱上)
#所以此时,要调用函数move(),而且目标柱是B柱,移动盘数是n-1,起点是A,终点是B,借助C去转移,即函数move(n-1,a,c,b)
#移动完成后,要把A最底下的盘子移动到C,这是确定的,所以直接打印A --> C即可
#接下来的目标就是完成剩下的在B柱上n-1个盘子的移动,move()函数就是用于将起点柱上的盘子移动到目标柱上的
#那么此时盘子数量为n-1,起点为B,终点为C,只需要调用函数move(n-1,b,a,c)
#不停地减少起点柱上盘子的数量,直到盘子数量为1,直接执行if语句即可
#这里注意要始终把参数位置记住,第一个参数永远是起点,第二个是中转,第三个才是终点!